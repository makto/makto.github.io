---
layout: note
category: note
---

## 前言

- 不是讲系统如何构建和实现，而是讲如何利用系统知识写出更好的程序
- 学习系统的唯一方法就是 do 系统
- [CS:APP]

[CS:APP]: http://csapp.cs.cmu.edu

## 第一章 计算机系统漫游

### 1.1 信息就是位+上下文
- 8 个位被组织成一组，称为字节
- ASCII 标准用唯一的单字节大小的整数值表示每个字符
- 只有 ASCII 字符构成的文件成为文本文件，所有其他文件都成为二进制文件
- 系统中的所有信息都是由一串位表示的
- 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文

### 1.2 程序被其他程序翻译成不同的格式
- 编译系统包括四部分：预处理器、编译器、汇编器、链接器
- 汇编器得到的`.o`文件是二进制的，它的 **字节编码** 是机器语言指令而不是字符，注意这里也用到了 *字节编码* 这个词

### 1.3 了解编译系统如何工作是大有益处的
### 1.4 处理器读并解释存储在存储器中的指令
- 系统的硬件组成
    - 总线
        - IO总线，携带信息字节，负责在各个部件间传递
        - 通常被设计成传送定长的字节块，也就是字（word）
        - 字中的字节数，称为字长，字长为4的即称为32位机（4*8=32）
    - IO设备
        - 鼠标、键盘、显示器、磁盘等
        - 每个 IO设备都通过控制器或适配器与IO总线相连，并传递信息
        - 控制器是置于IO设备本身或主板上的芯片组（比如USB）
        - 适配器则是一块主板插槽上的卡（如图形适配器）
    - 主存
        - 临时存储设备，处理器执行程序时用来存放程序和程序处理的数据
        - 物理上说，是一组动态随机存取存储器（DRAM）组成
        - 逻辑上说，是一个线性的字节数组，每个字节有唯一的地址，从零开始
    - 处理器
        - 解释（或执行）存储在主存中指令的引擎
        - 核心是一个字长的存储设备（寄存器），称为程序计数器（PC），任何时刻都指向主存中的某条机器指令
        - 寄存器文件，由一些一字长的寄存器组成
        - 算数/逻辑单元（ALU），计算新的数据和地址值
        - 指令集结构描述每条机器代码指令的效果，微体系结构描述处理器实际上如何实现
        - CPU从PC指向的地址读取指令，解释指令、执行指令，然后更新PC指向下一条指令

### 1.5 高速缓存至关重要
系统花费大量时间把信息从一个地方挪到另一个地方，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成

对处理器来说：

- 从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍
- 从寄存器文件中读数据的速度比从主存中读取几乎要快100倍
针对处理器和主存之间的差异：
- 采用了更小更快的存储设备，即高速缓存存储器
- L1高速缓存位于处理器芯片上
- L2高速缓存通过一条特殊的总线链接到处理器
- L1、L2高速缓存采用静态随机访问存储器（SRAM）的硬件技术实现

### 1.6 存储设备形成层次结构
存储器层次结构

- 从上至下，访问速度越来越慢，容量越来越大，每字节的造价越来越便宜
- 寄存器文件位于最顶部，即L0
- 主要思想是，一层上的存储器作为低一层存储器的高速缓存
- 可以利用对整个存储器层次结构的理解来提高程序性能

### 1.7 操作系统管理硬件
可以把操作系统看作应用程序和硬件之间插入的一层软件，它有两个基本功能：

- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备

操作系统通过几个基本的抽象概念来实现这两个功能：

- 进程
    - 是操作系统对正在运行的程序的一种抽象（或，对处理器、主存和I/O设备的抽象）
    - 并发运行的（程序独占系统的）假象是通过进程间切换来实现的，也就是上下文切换
    - 上下文是指，进程运行所需的所有状态信息，如PC和寄存器文件的当前值
    - 上下文切换时，OS保存当前进程的上下文，然后恢复新进程的上下文，从上次停止的地方开始执行
    - 一个进程可以由多个称为线程的执行单元组成，他们都运行在进程的上下文中，共享同样的代码、全局数据，多线程之间比多进程之间更容易共享数据，也更搞笑
- 虚拟存储器
    - 每个进程独占主存的假象，是通过虚拟地址空间（虚拟存储器）的概念实现的
    - 是对主存和磁盘I/O设备的抽象
    - 每个进程看到的虚拟地址空间由大量准确定义的区构成，从最低的地址开始，分别为
        - 程序代码和数据，直接按照可执行目标文件初始化
        - 堆，可以在运行时动态地收缩和扩展（通过malloc和free）
        - 共享库，如C标准库和数学库
        - 栈，编译器用来实现函数调用，在程序执行期间可以动态地扩展和收缩
        - 内核虚拟存储器，总是驻留在内存中，是OS的一部分
    - 基本思想是，把一个进程虚拟存储器的内容存储在磁盘上，然后用主存作为磁盘的高速缓存
- 文件
    - 文件就是文字序列
    - 是对I/O设备的抽象
    - 每个I/O设备，包括磁盘、键盘、显示器、甚至网络，都可以视为文件
    - 系统中的所有输入输出都是通过使用一小组成为Unix I/O的系统函数调用读写文件来实现的

### 1.8 系统之间利用网络通信
从一个单独的系统来看，网络可视为一个I/O设备

### 1.9 重要主题
- 并发和并行
    - 线程级并发
        - 单处理器系统通过分时技术来模拟并发
        - 多处理器系统包括多核处理器、超线程两种实现
        - 多核处理器是将多个CPU集成在一个集成电路芯片上
        - 超线程也称同时多线程，通过在单个周期中决定要执行哪个线程，从而更好地利用处理资源；因为常规的处理器需要大约20000个时钟周期做不同的线程间的转换，超线程技术可以减少这种开销
        - 多处理器的使用从两个方面提高系统性能：首先减少模拟并发的需要，其次可以使程序运行的更快
        - 需要程序以多线程的方式来书写
    - 指令级并发
        
        在较低的抽象层次上，处理器同时执行多条指令的属性
    - 单指令、多数据并行
        
        在最低层次上，处理器中特殊的硬件，允许一条指令产生多个可以并行执行的操作
- 抽象的重要性
    - 指令集结构提供了对实际处理器硬件的抽象
    - 虚拟机提供了对整个计算机的抽象（包括操作系统、处理器和程序）

### 联想
- shell 本质上也只是一个解释器？执行 shell 这种脚本语言？所有的 UNIX 命令只不过是放在特定位置的一些程序，shell 找到它并执行
- 其他用非 ASCII 字符编码方式（比如UTF-8）编码的文件难道不是文本文件？

### 其他
- GNU项目的目标是开发出一个完整的类Unix系统，其源代码能够不受限制地被修改和传播
- 现代开源运动的思想起源自GNU中自由软件的概念
- Posix目的是标准化Unix的开发，如系统调用的C语言接口、外壳程序、网络编程等
- C语言1969-1973创建，GNU项目1984年发起，1974年Unix发布，Linux在1991年4月开始酝酿，8月基本完成
